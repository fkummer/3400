/* 
 * This is the function responsible for the general line following logic.
 * It first reads the sensor values, determines the error based on our target
 * sensor reading by using a linear mapping function that maps the difference
 * between sensor readings to a range from -4 to 4. Additional logic at the end
 * of the function resposible for handling intersections has been omitted
 */
#include <Servo.h>

Servo myservo1;  // left wheel
Servo myservo2; // right wheel

char right_direction;
char left_direction;

  // Variables for reading the line sensor values:
char qti_left;
char qti_right;
int left_side;
int right_side;

  // The relative error between our current position over the line and our
  // desired position (ranges from -4 to 4):
int error;

  // "I" and "D" terms for the equation:
  // (Note: Though we kept track of the "I" term, we did not actually make use
  // of it)
float err_sum = 0;
float err_diff = 0;
float prev_err = 0; // this is used for determining the error difference

void setup(){
  Serial.begin(9600);
  myservo1.attach(9);  // left wheel
  myservo2.attach(10); // right wheel
  pinMode(A0, INPUT);
  pinMode(A1, INPUT);
  pinMode(A2, INPUT);
  pinMode(A3, INPUT);
  pinMode(A4, INPUT);
  pinMode(A5, INPUT);
  
  qti_left = analogRead(A4); // left front sensor
  qti_right = analogRead(A5); //right fron sensor
  left_side = analogRead(A2); //left sensor
  right_side = analogRead(A3); //right sensor
  myservo1.write(100);   //left sensor start speed
  myservo2.write(80);    //right sensor start speed 
}

void loop(){
   // First we read the line sensor values:
    //update_qtis(&qti_left, &qti_right);
    qti_left = analogRead(A4);
    qti_right = analogRead(A5);
    left_side = analogRead(A2);
    right_side = analogRead(A3);
  
    error = qti_left - qti_right; 
   
    /*Serial.println(left_side);
    Serial.println(right_side);*/
    
    if (left_side > 750 && right_side > 750){
      delay(100);
      myservo1.write(90);
      myservo2.write(90);
      delay(1000);
      myservo1.write(83);
      myservo2.write(83);
      delay(590);
      if (qti_right < 400){
        myservo1.write(83);
        myservo2.write(83);
      }
      //delay(500);
      
      /*myservo1.write(100);
      myservo2.write(80);
      delay(1000);*/
    }  
    else{
      Serial.println(error);
      if (error < 150 && error > -150) { 
        error = 0; 
        right_direction = (char)(80 + 0.08*error);
        left_direction = (char)(100 + 0.08*error);
      }
      
    }
    //right_direction = 90;  //for tuning the servos
    //left_direction = 90;
    right_direction = (char)(85 + 0.08*error);
    left_direction = (char)(95 + 0.08*error);
    //serial.println(error);
    myservo1.write(left_direction);
    myservo2.write(right_direction); 
    //}
    /*myservo1.write(83);
    myservo2.write(83);
    delay(500);
    myservo1.write(90);
    myservo2.write(90);
    delay(3000); */
    //myservo1.write(90);
    //myservo2.write(90); 
    
   //Serial.print(left_side);
    //Serial.print("        ");
    //Serial.println(right_side);
    
    
    
    //myservo1.write(left_direction);
    //myservo2.write(right_direction); 
    /*
    // Calculate our "I" and "D" terms
    err_sum += error;
    err_diff = error - prev_err;
    prev_err = error;  // Save this "P" term to determine the next "D" term
    */
}



