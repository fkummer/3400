/* 
 * This is the function responsible for the general line following logic.
 * It first reads the sensor values, determines the error based on our target
 * sensor reading by using a linear mapping function that maps the difference
 * between sensor readings to a range from -4 to 4. Additional logic at the end
 * of the function resposible for handling intersections has been omitted
 */
#include <Servo.h>

char onSide;
char LEFT = 0;
char RIGHT = 1;

Servo myservo1;  // left wheel
Servo myservo2; // right wheel
 
int pos = 0;    // variable to store the servo position 
int i;
int n;

char node_found = 0;
char left_direction;
char right_direction ; 
  // Variables for reading the line sensor values:
char qti_left;
char qti_right;
int left_side;
int right_side;
  // The relative error between our current position over the line and our
  // desired position (ranges from -4 to 4):
int error;

  // Variable used to keep track of the difference between the sensor readings:
int difference;

  // "I" and "D" terms for the equation:
  // (Note: Though we kept track of the "I" term, we did not actually make use
  // of it)
float err_sum = 0;
float err_diff = 0;
float prev_err = 0; // this is used for determining the error difference

  // Variables used for linear mapping or our sensor reading difference to an
  // error value:
  // error = m * difference + b <--- this equation (1) is used below
float m = 0.0308; //slope
float b = -3.31;

void setup(){
  Serial.begin(9600);
  myservo1.attach(9);  // left wheel
  myservo2.attach(10); // right wheel
  pinMode(A0, INPUT);
  pinMode(A1, INPUT);
  pinMode(A2, INPUT);
  pinMode(A3, INPUT);
  qti_left = analogRead(A0); // left sensor
  qti_right = analogRead(A1); //right sensor
  left_side = analogRead(A2);
  right_side = analogRead(A3);
  //myservo1.write(100);   //left sensor start speed
  //myservo2.write(80);    //right sensor start speed 
}

void loop(){
   // First we read the line sensor values:
    //update_qtis(&qti_left, &qti_right);
    qti_left = analogRead(A0);
    qti_right = analogRead(A1);
    left_side = analogRead(A2);
    right_side = analogRead(A3);
  
    error = qti_left - qti_right; 
    
    if (left_side > 750 && right_side > 750){
      myservo1.write(100);
      myservo2.write(80);
      delay(200);
      right_direction = 90;
      left_direction = 90;
      myservo1.write(left_direction);
      myservo2.write(right_direction); 
      delay(1000);
      myservo1.write(83);
      myservo2.write(83);
      delay(300); 
      myservo1.write(100);
      myservo2.write(80);
      delay(100);
      
    }
    else{
      if (error > 100 ) { 
      right_direction = (char)(80 + 0.1*error);
      left_direction = (char)(100 + 0.1*error);
    }
    else if (error < -100) {
      right_direction = (char)(80 + 0.1*error);
      left_direction = (char)(100 + 0.1*error);
    } 
    else { 
      error = 0; 
      right_direction = (char)(80 + 0.1*error);
      left_direction = (char)(100 + 0.1*error);
    }
    Serial.println(error);
    myservo1.write(left_direction);
    myservo2.write(right_direction); 
    }
    
    Serial.print(left_side);
    Serial.print("        ");
    Serial.println(right_side);
    
    
    
    //myservo1.write(left_direction);
    //myservo2.write(right_direction); 
    /*
    // Calculate our "I" and "D" terms
    err_sum += error;
    err_diff = error - prev_err;
    prev_err = error;  // Save this "P" term to determine the next "D" term
    */
}
